---
title: 'Association between investigating COVID-19 and design characteristics in global clinical trial registrations'
date: "`r format(Sys.Date(), format = '%d %b %Y')`"
output:
  html_document:
    df_print: paged
    code_folding: show
    keep_md: yes
    number_sections: yes
    toc: yes
    toc_depth: 5
    toc_float: yes
  pdf_document:
    number_sections: yes
editor_options:
  chunk_output_type: console
---


```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(fig.width = 5, fig.height = 5, echo = TRUE, eval = TRUE, message = TRUE, warning = TRUE, error = TRUE, cache = TRUE, cache.path = "cache/", fig.path = paste0("figures/", knitr::opts_chunk$get("fig.path")), dev = c("png"))

```

```{r load, warning = FALSE, message = FALSE, include = FALSE}
library(powerMediation)
library(tidyverse)
library(table1)
library(readxl)

forestplot_height <- 15

```

```{r}
# main dataset
d_import <- read_csv("data/final_dataset.csv", guess_max = 3000, na = c("Unreported", "NA"))

# 15% sample needed for calculating contradictions
d_man <- read_xlsx("data/manual_processing/manual_extraction/Manual_extraction_all.xlsx")
  
d <- d_import %>% 
  select(TrialID, study_arm:analyst_blind) %>%
  mutate_if(is.character, as.factor)

# convergence issues with source registry, so group infrequent categories
d <- d %>% 
  mutate(source_registry = fct_lump_n(d$source_registry, n = 6))

# for use in analysis 10
main_dataset_2 <- d[which(d$study_arm %in% c("covid", "main")),]
main_dataset_2$covid <- (main_dataset_2$study_arm == "covid")

indication_dataset_2 <- d[which(d$study_arm %in% c("covid", "im")),]
indication_dataset_2$covid <- (indication_dataset_2$study_arm == "covid")
```

# Outlier check
```{r}
hist(d_import$sample_size)
```

Manual check of some of the highest ones indicates that they are accurate. 

```{r wrangle}

# label variables for table1
label(d$control_arm) <- "Control arm"
label(d$randomisation) <- "Randomisation"
label(d$blinding) <- "Blinding"
label(d$prospective) <- "Prospective registration"
label(d$source_registry) <- "Source registry"
label(d$phase_clean) <- "Phase"
label(d$region_Africa) <- "Africa"
label(d$region_N_America) <- "North America"
label(d$region_L_America) <- "Latin America"
label(d$region_Asia) <- "Asia"
label(d$region_Europe) <- "Europe"
label(d$region_Oceania) <- "Oceania"
label(d$multicentre) <- "Multicentre"
label(d$primary_purpose) <- "Primary purpose"
label(d$sponsor_type) <- "Sponsor type"
label(d$sample_size) <- "Sample size"
label(d$vaccine) <- "Vaccine"
label(d$conventional) <- "Conventional"
label(d$traditional) <- "Traditional"
label(d$subject_blind) <- "Subject blind"
label(d$caregiver_blind) <- "Caregiver blind"
label(d$investigator_blind) <- "Investigator blind"
label(d$outcome_blind) <- "Outcome blind"
label(d$analyst_blind) <- "Analyst blind"

d_man <- d_man %>% 
  filter(Exclude != "Yes")
```

The following was used for quality control criterion #3.

```{r contradictions}
table(d_man$ContradictionControlArm, useNA = "ifany")
table(d_man$ContradictionRandomisation, useNA = "ifany")
table(d_man$ContradictionBlinding, useNA = "ifany")
table(d_man$ContradictionProspectiveRegistration, useNA = "ifany")

prop.table(table(d_man$ContradictionControlArm, useNA = "ifany")) * 100
prop.table(table(d_man$ContradictionRandomisation, useNA = "ifany")) * 100
prop.table(table(d_man$ContradictionBlinding, useNA = "ifany")) * 100
prop.table(table(d_man$ContradictionProspectiveRegistration, useNA = "ifany")) * 100
```

# Descriptive
This is what the data look like before changing any of the variables as per the protocol (e.g. before changing randomisation = Not applicable to randomisation = No). This is Table 4 in the paper.

```{r}

# make col headings nicer
d_tab <- d %>% 
  mutate(study_arm = 
           case_when(study_arm == "covid" ~ "Covid",
                     study_arm == "im" ~ "Indication matched", 
                     study_arm == "main" ~ "Main"))

# group together infrequent source registries for a nicer table
# d_tab <- d_tab %>% 
#   mutate(source_registry = fct_lump_n(d_tab$source_registry, n = 6))
  
table1(~ control_arm + randomisation + blinding + prospective + 
         source_registry + phase_clean + 
         region_Africa + region_N_America + region_L_America + 
         region_Asia + region_Europe + region_Oceania + 
         multicentre + primary_purpose + sponsor_type + sample_size + 
         vaccine + conventional + traditional + 
         subject_blind + caregiver_blind + investigator_blind + 
         outcome_blind + analyst_blind
       | study_arm, 
       data=d_tab, overall = "All",
       render.continuous=c(.="Mean (SD)", .="Median [Q1, Q3]"))
```

We specified that we would treat unknown/unreported values in particular ways. We implement this here to generate the dataset for analysis.

```{r}
d$randomisation[d$randomisation == "Not applicable"] <- "No"
d$randomisation[is.na(d$randomisation)]<- "No"
d$blinding[is.na(d$blinding)]<- "No"
d$multicentre[is.na(d$multicentre)] <- "No"

# this is a deviation agreed with the editor
d$control_arm[is.na(d$control_arm)] <- "No"

# d$sample_size <- log(d$sample_size)
# to impute: phase, sample size (for only 3 trials) and sponsor type
```

# Check log sample size
Below we checked the linearity in the logit assumption as per the preregistration. Generally log transformed sample size appeared to be better. 

```{r linearity logit}
# check linearity in logit 

d_check <- d
d_check <- d_check[-which(is.na(d_check$sample_size)), ]

quantile(d_check$sample_size, probs = seq(0, 1, 1/5), na.rm = T)

d_check <- d_check %>% 
  mutate(
    quintile_group = 
      case_when(sample_size <= 38 ~ "1",
                sample_size > 38 & sample_size <=70 ~ "2",
                sample_size > 70 & sample_size <=133 ~ "3",
                sample_size > 133 & sample_size <=342.6 ~ "4",
                sample_size > 342.6 ~ "5")
  ) 

table(d_check$control_arm)
d_check$control_arm <- as.character(d_check$control_arm)
d_check[d_check$control_arm == "Yes",]$control_arm <- "1"
d_check[d_check$control_arm == "No",]$control_arm <- "0"
d_check$control_arm <- as.numeric(d_check$control_arm)

d_check$randomisation <- as.character(d_check$randomisation)
d_check[d_check$randomisation == "Yes",]$randomisation <- "1"
d_check[d_check$randomisation == "No",]$randomisation <- "0"
d_check$randomisation <- as.numeric(d_check$randomisation)

d_check$blinding <- as.character(d_check$blinding)
d_check[d_check$blinding == "Yes",]$blinding <- "1"
d_check[d_check$blinding == "No",]$blinding <- "0"
d_check$blinding <- as.numeric(d_check$blinding)

d_check$prospective <- as.character(d_check$prospective)
d_check[d_check$prospective == "Yes",]$prospective <- "1"
d_check[d_check$prospective == "No",]$prospective <- "0"
d_check$prospective <- as.numeric(d_check$prospective)

s <- d_check %>% 
  group_by(quintile_group) %>% 
  summarise(prop = sum(control_arm)/ length(control_arm),
            log_odds_control = log(prop / (1-prop)),
            prop = sum(randomisation)/ length(randomisation),
            log_odds_randomisation = log(prop / (1-prop)),
            prop = sum(blinding)/ length(blinding),
            log_odds_blinding = log(prop / (1-prop)),
            prop = sum(prospective)/ length(prospective),
            log_odds_prospective = log(prop / (1-prop)),
            median = median(sample_size),
            median_log = median(log(sample_size)))


plot(s$median, s$log_odds_control)
plot(s$median, s$log_odds_randomisation)
plot(s$median, s$log_odds_blinding)
plot(s$median, s$log_odds_prospective)

plot(s$median_log, s$log_odds_control)
plot(s$median_log, s$log_odds_randomisation)
plot(s$median_log, s$log_odds_blinding)
plot(s$median_log, s$log_odds_prospective)

# log sample size seems better fit

d$sample_size <- log(d$sample_size)

```

# Summary of data

```{r}
summary(d)
```

# Summary of missing data

```{r, fig.width = 15, fig.height = 7}
# mice::md.pattern(d)
VIM::aggr(d, numbers = TRUE, sortVars = TRUE, labels = names(data), cex.axis = 0.7, gap = 3, ylab = c("Proportion of missingness", "Missingness Pattern"), oma = c(10, 5, 5, 3))
# VIM::marginplot(d[,c(1, 2)])
```

# Power analysis

We calculated power as follows. This code is retained here as some of the values are used later in the script.

```{r power variables}
# inputs for power analysis 
n_comparisons <- 4
total_alpha <- 0.05
alpha <- total_alpha/n_comparisons
z <- qnorm(1-alpha/2)
power <- 0.95
p1 <- 0.5 # probability of outcome in COVID group
p2 <- 0.6 # probability of outcome in comparator group
prop <- 0.5 # proportion of sample in comparator group

# power calculation 
sample_size <- SSizeLogisticBin(p1 = p1, p2 = p2, B = prop, alpha = alpha, power = power)
```

The required sample size with power = `r power*100`% and alpha = `r total_alpha` for `r n_comparisons` comparisons, to detect a `r (p2 - p1)*100`% difference between groups assuming `r p1` probability of outcome in the COVID-19 group is `r sample_size`. 

# Analysis

## Some more summaries

```{r}
table(d$study_arm, useNA = "ifany")
```

Generate main and indication-matched datasets:

```{r}
main_dataset <- d[which(d$study_arm %in% c("covid", "main")),]
main_dataset$covid <- (main_dataset$study_arm == "covid")


indication_dataset <- d[which(d$study_arm %in% c("covid", "im")),]
indication_dataset$covid <- (indication_dataset$study_arm == "covid")

```

## Tables of each outcome by other variables
Note that these have log sample size. 

### Control arm

```{r}
table1::table1(~ control_arm + randomisation + blinding + prospective + source_registry + phase_clean + region_Africa + region_N_America + region_L_America + region_Asia + region_Europe + region_Oceania + multicentre + primary_purpose + sponsor_type + sample_size + vaccine + conventional + traditional + subject_blind + caregiver_blind + investigator_blind + outcome_blind + analyst_blind | study_arm * control_arm, data = d)

```

### Randomisation

```{r}
table1::table1(~ control_arm + randomisation + blinding + prospective + source_registry + phase_clean + region_Africa + region_N_America + region_L_America + region_Asia + region_Europe + region_Oceania + multicentre + primary_purpose + sponsor_type + sample_size + vaccine + conventional + traditional + subject_blind + caregiver_blind + investigator_blind + outcome_blind + analyst_blind | study_arm * randomisation, data = d)
```

### Blinding

```{r}
table1::table1(~ control_arm + randomisation + blinding + prospective + source_registry + phase_clean + region_Africa + region_N_America + region_L_America + region_Asia + region_Europe + region_Oceania + multicentre + primary_purpose + sponsor_type + sample_size + vaccine + conventional + traditional + subject_blind + caregiver_blind + investigator_blind + outcome_blind + analyst_blind | study_arm * blinding, data = d)
```

### Prospective registration

```{r}
table1::table1(~ control_arm + randomisation + blinding + prospective + source_registry + phase_clean + region_Africa + region_N_America + region_L_America + region_Asia + region_Europe + region_Oceania + multicentre + primary_purpose + sponsor_type + sample_size + vaccine + conventional + traditional + subject_blind + caregiver_blind + investigator_blind + outcome_blind + analyst_blind | study_arm * prospective, data = d)
```

## Outcomes over time (analysis 3)
## Covid trial characteristics over time 

Results number 3. Trials with missing start date (23) are dropped. 

```{r covid-over-time}
d_cov <- d %>% 
  filter(study_arm == "covid")

# sum(is.na(d_cov$start_date))

d_sum <- d_cov %>% 
    group_by(month = lubridate::floor_date(start_date, "month")) %>% 
    summarize(Controlled = sum(control_arm == "Yes")/n(),
              Randomised = sum(randomisation == "Yes")/n(),
              Blinded = sum(blinding == "Yes")/n(), 
              Prospective = sum(prospective == "Yes")/n()) %>% 
  gather(key = "variable", value = "value", -month) %>% 
  rename(Variable = variable) %>% 
  filter(complete.cases(.))

# d_sum <- d_sum %>% 
#   filter(month > "2019-01-01" & month < "2020-01-01")

ggplot(d_sum, aes(x = month, y = value)) + 
  geom_line(aes(color = Variable, linetype = Variable)) + 
  theme_classic() + 
  labs(x = "Start date (grouped by month)", 
       y = "Proportion") +
  theme(legend.title = element_blank()) + 
  ylim(0,1)

```

## Direct effect (analyses 4 and 5)

### Complete case analysis

For each outcome we fit a logistic regression model with adjustment for all covariates, not including the other outcomes.

```{r direct models main}
# define outcome variables
myvars <- c("control_arm", "randomisation", "blinding", "prospective")

# define the adjustment set. 
main_direct_adjustment <- main_dataset %>%
  select(covid, source_registry:traditional) %>% 
  names()

# originally this was the same as main, but there were problems with
# convergence, so intervention variables are dropped
indication_direct_adjustment <- main_dataset %>%
  select(covid, source_registry:traditional) %>% 
  select(-vaccine, -conventional, -traditional) %>% 
  names()

# logistic regression for each outcome
main_direct_models <- lapply(myvars, function (x){
  glm(as.formula(paste(x, "~", paste(main_direct_adjustment, collapse = "+"))),
      family = binomial(link = "logit"),
      data = main_dataset)
})

```

We are adjusting for `r paste(main_direct_adjustment, collapse = ", ")`. Adjusting for `source_registry` leads to convergence problems so this variable has been excluded. Same with `conventional` (convergence problems for indication dataset).

#### Main dataset

```{r direct models main results, fig.height = forestplot_height}

sjPlot::tab_model(main_direct_models)

sjPlot::plot_models(main_direct_models, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1)
```

#### Indication-matched dataset

We repeat the same analyses on the indication-matched dataset.

```{r direct models indication}
# logistic regression for each outcome
indication_direct_models <- lapply(myvars, function (x){
  glm(as.formula(paste(x, "~", paste(indication_direct_adjustment, collapse = "+"))),
      family = binomial(link = "logit"),
      data = indication_dataset)
})

names(indication_direct_models) <- paste0(myvars, "_(direct_indication)")
```

```{r direct models indication results, fig.height = forestplot_height}
# lapply(indication_direct_models, summary)

sjPlot::tab_model(indication_direct_models)

sjPlot::plot_models(indication_direct_models, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1) # prefix.labels = "label"
```

### Multiple imputation

Phase, sample size (for 3 trials) and sponsor type have missing values.

#### Main dataset

```{r}
# generate start_year from start_date
main_dataset$start_year <- as.numeric(substr(main_dataset$start_date, 1, 4))

# create a new dataset where some variables are dropped
main_for_mice <- main_dataset %>% select(-TrialID, -start_date, -study_arm)

main_for_mice %>% map(class)
```

Use the `mice` command to generate an initial predictor matrix (indicating which column variables are used to predict the row variables) without making any imputations.

```{r}
set.seed(5)

mice_in <- mice::mice(main_for_mice, maxit = 0, print = FALSE)
predictor_matrix <- mice_in$pred

```

```{r correlation matrix main direct}
correlation_matrix <- round(cor(sapply(main_for_mice[,c(myvars, main_direct_adjustment)], as.numeric), use = "pairwise.complete.obs"), 2)

# keep only upper triangle
correlation_matrix[lower.tri(correlation_matrix)] <- NA
melted_correlation_matrix <- reshape2::melt(correlation_matrix)
# lower triangle
melted_correlation_matrix$Var2 <- factor(melted_correlation_matrix$Var2, levels(melted_correlation_matrix$Var2)[seq(length(levels(melted_correlation_matrix$Var2)), 1, by = -1)], ordered = TRUE)

labels_plot <- sapply(levels(melted_correlation_matrix[,1]), function(x) gsub("_", "", x))

ggplot(data = melted_correlation_matrix, aes(x = Var1, y = Var2, fill = value)) + geom_tile(color = "white") + xlab("") + ylab("") + scale_fill_gradient2(low = "darkorchid4", high = "green3", mid = "white", midpoint = 0, na.value = "white", limit = c(-1, 1), name = "Correlation") + scale_x_discrete(labels = labels_plot) + scale_y_discrete(labels = labels_plot[length(labels_plot):1]) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),                                     
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_rect(fill = "white"),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.7, 0.7),
  legend.direction = "horizontal") + guides(fill = guide_colorbar(barwidth = 7, barheight = 1, title.position = "top", title.hjust = 0.5))
```

```{r, eval = FALSE}
# quickpred: quick selection procedure of predictors
# select predictors according to data relations with a minimum correlation of ρ = 0.25
mice_in2 <- mice::mice(main_for_mice, pred = mice::quickpred(main_for_mice, mincor = 0.25), print = FALSE)
mice_in2$pred
```

Modify the predictor matrix such that only phase, sample size and sponsor type are imputed, using all variables. <!-- except `TrialID` and `start_date`.-->

```{r}
predictor_matrix[,"covid"] <- 1 # no need to set element in row 'covid' to 0 because the entire row will be set to 0 below
predictor_matrix[which(!(row.names(predictor_matrix) %in% c("phase_clean", "sample_size", "sponsor_type"))),] <- 0
```

Generate 10 imputed datasets using chained equations (using package `mice`).

```{r}
main_mice <- mice::mice(main_for_mice, m = 10, pred = predictor_matrix, print = FALSE)

attributes(main_mice)
```

Original data:

```{r}
main_mice$data %>% head
```

Imputed datasets:

```{r}
main_mice$imp %>% map(head)

# In order to get the third imputed data set, use the complete() function
```

Only impute the three variables listed above.

```{r}
method_vector <- main_mice$method
method_vector[19:length(method_vector)] <- ""

```

Generate 10 imputed datasets using the updated `method` vector.

```{r}
main_mice <- mice::mice(main_for_mice, method = method_vector, m = 10, pred = predictor_matrix, print = FALSE)
```

```{r}
plot(main_mice)
```

Check that there is no trend with further iterations and that the lines mix.

```{r}
main_mice_40 <- mice::mice.mids(main_mice, maxit = 40, print = FALSE)
plot(main_mice_40)
```

Plot of observed (blue) and imputed (red) phase:

```{r}
mice::stripplot(main_mice, phase_clean ~ .imp, pch = 20, cex = 2)

# Under MCAR, univariate distributions of the observed and imputed data are expected to be identical. Under MAR, they can be different, both in location and spread, but their multivariate distribution is assumed to be identical.
```

```{r}
mice::stripplot(main_mice)
```

##### Analysis

Logistic regression analysis on the multiply imputed data.

```{r direct models main mice}
main_direct_models_mice <- lapply(myvars, function (x){
  fit <- with(main_mice, glm(as.formula(paste(x, "~", paste(main_direct_adjustment, collapse = "+"))),
                             family = binomial(link = "logit")))
  pooled_fit <- mice::pool(fit)
  return(list("fit" = fit, "pooled_fit" = pooled_fit))
                            })

names(main_direct_models_mice) <- myvars
```

```{r direct models main results mice, fig.height = forestplot_height}
lapply(main_direct_models_mice, function(x) summary(x$pooled_fit))

sum_main_direct_mice <- lapply(main_direct_models_mice, function(x) summary(x$pooled_fit))

# OR and 95% CI (Bonferroni corrected)
pool_OR_main_direct_mice <- lapply(sum_main_direct_mice, function(x) {
  cbind(exp(cbind(x[2,2], (x[2,2]-z*(x[2,3])), 
           (x[2,2]+z*(x[2,3])))), x[2,6])
})

pool_OR_main_direct_mice <- do.call(rbind.data.frame, pool_OR_main_direct_mice)
colnames(pool_OR_main_direct_mice) <- c("Estimate", "Lower CI", "Upper CI", "P-value")
pool_OR_main_direct_mice$Analysis <- "Main direct (4)"
```

`fmi`: fraction of information about the coefficients missing due to nonresponse  
`lambda`: proportion of the variation attributable to the missing data  

```{r}
mice::densityplot(main_mice, ~ phase_clean)
mice::densityplot(main_mice, ~ sponsor_type)
mice::densityplot(main_mice, ~ sample_size)
```

##### Compare complete case analysis with MICE analysis for the each outcome

###### Control arm

```{r}
summary(glm(as.formula(paste("control_arm", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("control_arm", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Randomisation

```{r}
summary(glm(as.formula(paste("randomisation", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("randomisation", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Blinding

```{r}
summary(glm(as.formula(paste("blinding", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("blinding", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Prospective registration

```{r}
summary(glm(as.formula(paste("prospective", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("prospective", "~", paste(main_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

#### Indication-matched dataset

```{r}
# generate start_year from start_date
indication_dataset$start_year <- as.numeric(substr(indication_dataset$start_date, 1, 4))

# create a new dataset where some variables are dropped
indication_for_mice <- indication_dataset %>% select(-TrialID, -start_date, -study_arm)

indication_for_mice %>% map(class)
```

Use the `mice` command to generate an initial predictor matrix (indicating which column variables are used to predict the row variables) without making any imputations.

```{r}
set.seed(5)

mice_in <- mice::mice(indication_for_mice, maxit = 0, print = FALSE)
predictor_matrix <- mice_in$pred

```

```{r correlation matrix indication direct}
correlation_matrix <- round(cor(sapply(indication_for_mice[,c(myvars, indication_direct_adjustment)], as.numeric), use = "pairwise.complete.obs"), 2)
# keep only upper triangle
correlation_matrix[lower.tri(correlation_matrix)] <- NA
melted_correlation_matrix <- reshape2::melt(correlation_matrix)
# lower triangle
melted_correlation_matrix$Var2 <- factor(melted_correlation_matrix$Var2, levels(melted_correlation_matrix$Var2)[seq(length(levels(melted_correlation_matrix$Var2)), 1, by = -1)], ordered = TRUE)

# labels_plot <- levels(melted_correlation_matrix[,1])
# labels_plot <- labels[levels(melted_correlation_matrix[,1]),]$short
labels_plot <- sapply(levels(melted_correlation_matrix[,1]), function(x) gsub("_", "", x))

ggplot(data = melted_correlation_matrix, aes(x = Var1, y = Var2, fill = value)) + geom_tile(color = "white") + xlab("") + ylab("") + scale_fill_gradient2(low = "darkorchid4", high = "green3", mid = "white", midpoint = 0, na.value = "white", limit = c(-1, 1), name = "Correlation") + scale_x_discrete(labels = labels_plot) + scale_y_discrete(labels = labels_plot[length(labels_plot):1]) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),                                     
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
# panel.background = element_blank(),
  panel.background = element_rect(fill = "white"),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.7, 0.7),
  legend.direction = "horizontal") + guides(fill = guide_colorbar(barwidth = 7, barheight = 1, title.position = "top", title.hjust = 0.5))
```

```{r, eval = FALSE}
# quickpred: quick selection procedure of predictors
# select predictors according to data relations with a minimum correlation of ρ = 0.25
mice_in2 <- mice::mice(indication_for_mice, pred = mice::quickpred(indication_for_mice, mincor = 0.25), print = FALSE)
mice_in2$pred
```

Modify the predictor matrix such that only phase, sample size and sponsor type are imputed, using all variables. <!-- except `TrialID` and `start_date`.-->

```{r}
predictor_matrix[,"covid"] <- 1 # no need to set element in row 'covid' to 0 because the entire row will be set to 0 below
predictor_matrix[which(!(row.names(predictor_matrix) %in% c("phase_clean", "sample_size", "sponsor_type"))),] <- 0
```

Generate 10 imputed datasets using chained equations (using package `mice`).

```{r}
indication_mice <- mice::mice(indication_for_mice, m = 10, pred = predictor_matrix , print = FALSE)

attributes(indication_mice)
```

Original data:

```{r}
indication_mice$data %>% head
```

Imputed datasets:

```{r}
indication_mice$imp %>% map(head)

# In order to get the third imputed data set, use the complete() function

# c3 <- complete(imp, 3) 
# md.pattern(c3)

# c.long <- complete(imp, "long") # "broad"
```

Only impute the three variables listed above.

```{r}
method_vector <- indication_mice$method
method_vector[19:length(method_vector)] <- ""

# methods(mice)
```

Generate 10 imputed datasets using the updated `method` vector.

```{r}
indication_mice <- mice::mice(indication_for_mice, method = method_vector, m = 10, pred = predictor_matrix, print = FALSE)
```

```{r}
plot(indication_mice)
```

Check that there is no trend with further iterations and that the lines mix.

```{r}
indication_mice_40 <- mice::mice.mids(indication_mice, maxit = 40, print = FALSE)
plot(indication_mice_40)
```

Plot of observed (blue) and imputed (red) phase:

```{r}
mice::stripplot(indication_mice, phase_clean ~ .imp, pch = 20, cex = 2)

# Under MCAR, univariate distributions of the observed and imputed data are expected to be identical. Under MAR, they can be different, both in location and spread, but their multivariate distribution is assumed to be identical.
```

```{r}
mice::stripplot(indication_mice)
```

##### Analysis

Logistic regression analysis on the multiply imputed data.

```{r direct models indication mice}
indication_direct_models_mice <- lapply(myvars, function (x){
  fit <- with(indication_mice, glm(as.formula(paste(x, "~", paste(indication_direct_adjustment, collapse = "+"))),
                             family = binomial(link = "logit")))
  pooled_fit <- mice::pool(fit)
  return(list("fit" = fit, "pooled_fit" = pooled_fit))
                            })

names(indication_direct_models_mice) <- myvars
```

```{r direct models indication results mice, fig.height = forestplot_height}
lapply(indication_direct_models_mice, function(x) summary(x$pooled_fit))

sum_indication_direct_mice <- lapply(indication_direct_models_mice, function(x) summary(x$pooled_fit))

# OR and 95% CI (Bonferroni corrected)
pool_OR_indication_direct_mice <- lapply(sum_indication_direct_mice, function(x) {
  cbind(exp(cbind(x[2,2], (x[2,2]-z*(x[2,3])), 
           (x[2,2]+z*(x[2,3])))), x[2,6])
})

pool_OR_indication_direct_mice <- do.call(rbind.data.frame, pool_OR_indication_direct_mice)
pool_OR_indication_direct_mice$Analysis <- "IM direct (5)"

# sjPlot::tab_model(indication_direct_models_mice)
# sjPlot::plot_models(indication_direct_models_mice, prefix.labels = "varname") + theme_bw()
```

`fmi`: fraction of information about the coefficients missing due to nonresponse  
`lambda`: proportion of the variation attributable to the missing data  

```{r}
mice::densityplot(indication_mice, ~ phase_clean)
mice::densityplot(indication_mice, ~ sponsor_type)
mice::densityplot(indication_mice, ~ sample_size)
```

##### Compare complete case analysis with MICE analysis for the each outcome

###### Control arm

```{r}
summary(glm(as.formula(paste("control_arm", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("control_arm", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Randomisation

```{r}
summary(glm(as.formula(paste("randomisation", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("randomisation", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Blinding

```{r}
summary(glm(as.formula(paste("blinding", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("blinding", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Prospective registration

```{r}
summary(glm(as.formula(paste("prospective", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("prospective", "~", paste(indication_direct_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

## Total effect (analyses 6 and 7)

We repeat the main analysis adjusting only for confounding variables.

### Complete case analysis

#### Main dataset

```{r total models main}
# define adjustment set. This is the same for the main and indication dataset
main_total_adjustment <- c("covid", "sponsor_type")

indication_total_adjustment <- main_total_adjustment

main_total_models <- lapply(myvars, function (x){
  glm(as.formula(paste(x, "~", paste(main_total_adjustment, collapse = "+"))),
      family = binomial(link = "logit"),
      data = main_dataset)
})

names(main_total_models) <- paste0(myvars, "_(total)")
```

```{r total models main results, fig.height = forestplot_height / 4}
# lapply(main_total_models, summary)

sjPlot::tab_model(main_total_models)

sjPlot::plot_models(main_total_models, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1)

# library(sjmisc)
```

#### Indication-matched dataset

We repeat the same analyses on the indication-matched dataset.

```{r total models indication}
# logistic regression for each outcome
indication_total_models <- lapply(myvars, function (x){
  glm(as.formula(paste(x, "~", paste(indication_total_adjustment, collapse = "+"))),
      family = binomial(link = "logit"),
      data = indication_dataset)
})

names(indication_total_models) <- paste0(myvars, "_(total_indication)")
```

```{r total models indication results, fig.height = forestplot_height / 4}
# lapply(indication_total_models, summary)

# lapply(indication_total_models, function(x) knitr::kable(exp(confint(x)), digits = 2))
# lapply(indication_total_models, function(x) print(sjPlot::tab_model(x)))

sjPlot::tab_model(indication_total_models)

sjPlot::plot_models(indication_total_models, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1)
```

### Multiple imputation

Phase, sample size (for 3 trials) and sponsor type have missing values. Here only sponsor type is to be imputed.

#### Main dataset

Use the `mice` command to generate an initial predictor matrix (indicating which column variables are used to predict the row variables) without making any imputations.

```{r}
set.seed(5)

mice_in <- mice::mice(main_for_mice, maxit = 0, print = FALSE)
# mice_in <- mice::mice(main_dataset, maxit = 0, print = FALSE)
predictor_matrix <- mice_in$pred

# warning message: Number of logged events: 1
```

```{r correlation matrix main total}
correlation_matrix <- round(cor(sapply(main_for_mice[,c(myvars, main_total_adjustment)], as.numeric), use = "pairwise.complete.obs"), 2)
# correlation_matrix <- round(cor(na.omit(values)), 2)
# keep only upper triangle
correlation_matrix[lower.tri(correlation_matrix)] <- NA
melted_correlation_matrix <- reshape2::melt(correlation_matrix)
# lower triangle
melted_correlation_matrix$Var2 <- factor(melted_correlation_matrix$Var2, levels(melted_correlation_matrix$Var2)[seq(length(levels(melted_correlation_matrix$Var2)), 1, by = -1)], ordered = TRUE)

# labels_plot <- levels(melted_correlation_matrix[,1])
# labels_plot <- labels[levels(melted_correlation_matrix[,1]),]$short
labels_plot <- sapply(levels(melted_correlation_matrix[,1]), function(x) gsub("_", "", x))

ggplot(data = melted_correlation_matrix, aes(x = Var1, y = Var2, fill = value)) + geom_tile(color = "white") + xlab("") + ylab("") + scale_fill_gradient2(low = "darkorchid4", high = "green3", mid = "white", midpoint = 0, na.value = "white", limit = c(-1, 1), name = "Correlation") + scale_x_discrete(labels = labels_plot) + scale_y_discrete(labels = labels_plot[length(labels_plot):1]) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),                                     
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
# panel.background = element_blank(),
  panel.background = element_rect(fill = "white"),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.7, 0.7),
  legend.direction = "horizontal") + guides(fill = guide_colorbar(barwidth = 7, barheight = 1, title.position = "top", title.hjust = 0.5))
```

```{r, eval = FALSE}
# quickpred: quick selection procedure of predictors
# select predictors according to data relations with a minimum correlation of ρ = 0.25
mice_in2 <- mice::mice(main_for_mice, pred = mice::quickpred(main_for_mice, mincor = 0.25), print = FALSE)
mice_in2$pred
```

Modify the predictor matrix such that only sponsor type is imputed, using all variables. <!-- except `TrialID` and `start_date`.-->

```{r}
predictor_matrix[,"covid"] <- 1 # no need to set element in row 'covid' to 0 because the entire row will be set to 0 below
predictor_matrix[which(!(row.names(predictor_matrix) %in% c("sponsor_type"))),] <- 0
```

Generate 10 imputed datasets using chained equations (using package `mice`).

```{r}
main_mice <- mice::mice(main_for_mice, m = 10, pred = predictor_matrix , print = FALSE)

attributes(main_mice)
```

Original data:

```{r}
main_mice$data %>% head
```

Imputed datasets:

```{r}
main_mice$imp %>% map(head)

# In order to get the third imputed data set, use the complete() function

# c3 <- complete(imp, 3) 
# md.pattern(c3)

# c.long <- complete(imp, "long") # "broad"
```

Only impute sponsor type.

```{r}
method_vector <- main_mice$method
method_vector[-15] <- ""

# methods(mice)
```

Generate 10 imputed datasets using the updated `method` vector.

```{r}
main_mice <- mice::mice(main_for_mice, method = method_vector, m = 10, pred = predictor_matrix, print = FALSE)
```

```{r}
plot(main_mice)
```

Check that there is no trend with further iterations and that the lines mix.

```{r}
main_mice_40 <- mice::mice.mids(main_mice, maxit = 40, print = FALSE)
plot(main_mice_40)
```

Plot of observed (blue) and imputed (red) phase:

```{r}
mice::stripplot(main_mice, phase_clean ~ .imp, pch = 20, cex = 2)

# Under MCAR, univariate distributions of the observed and imputed data are expected to be identical. Under MAR, they can be different, both in location and spread, but their multivariate distribution is assumed to be identical.
```

```{r}
mice::stripplot(main_mice)
```

##### Analysis

Logistic regression analysis on the multiply imputed data.

```{r total models main mice}
main_total_models_mice <- lapply(myvars, function (x){
  fit <- with(main_mice, glm(as.formula(paste(x, "~", paste(main_total_adjustment, collapse = "+"))),
                             family = binomial(link = "logit")))
  pooled_fit <- mice::pool(fit)
  return(list("fit" = fit, "pooled_fit" = pooled_fit))
                            })

names(main_total_models_mice) <- myvars
```

```{r total models main results mice, fig.height = forestplot_height}
lapply(main_total_models_mice, function(x) summary(x$pooled_fit))

sum_main_total_mice <- lapply(main_total_models_mice, function(x) summary(x$pooled_fit))

# OR and 95% CI (Bonferroni corrected)
pool_OR_main_total_mice <- lapply(sum_main_total_mice, function(x) {
  cbind(exp(cbind(x[2,2], (x[2,2]-z*(x[2,3])), 
           (x[2,2]+z*(x[2,3])))), x[2,6])
})
do.call(rbind.data.frame, pool_OR_main_total_mice) 

pool_OR_main_total_mice <- do.call(rbind.data.frame, pool_OR_main_total_mice)
pool_OR_main_total_mice$Analysis <- "Main total (6)"

# sjPlot::tab_model(main_total_models_mice)
# sjPlot::plot_models(main_total_models_mice, prefix.labels = "varname") + theme_bw()
```

`fmi`: fraction of information about the coefficients missing due to nonresponse  
`lambda`: proportion of the variation attributable to the missing data  

```{r}
mice::densityplot(main_mice, ~ sponsor_type)
```

##### Compare complete case analysis with MICE analysis for the each outcome

###### Control arm

```{r}
summary(glm(as.formula(paste("control_arm", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("control_arm", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Randomisation

```{r}
summary(glm(as.formula(paste("randomisation", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("randomisation", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Blinding

```{r}
summary(glm(as.formula(paste("blinding", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("blinding", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Prospective registration

```{r}
summary(glm(as.formula(paste("prospective", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = main_dataset))

fit <- with(main_mice, glm(as.formula(paste("prospective", "~", paste(main_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

#### Indication-matched dataset

Use the `mice` command to generate an initial predictor matrix (indicating which column variables are used to predict the row variables) without making any imputations.

```{r}
set.seed(5)

mice_in <- mice::mice(indication_for_mice, maxit = 0, print = FALSE)
# mice_in <- mice::mice(indication_dataset, maxit = 0, print = FALSE)
predictor_matrix <- mice_in$pred

# warning message: Number of logged events: 1
```

```{r correlation matrix indication total}
correlation_matrix <- round(cor(sapply(indication_for_mice[,c(myvars, indication_total_adjustment)], as.numeric), use = "pairwise.complete.obs"), 2)
# correlation_matrix <- round(cor(na.omit(values)), 2)
# keep only upper triangle
correlation_matrix[lower.tri(correlation_matrix)] <- NA
melted_correlation_matrix <- reshape2::melt(correlation_matrix)
# lower triangle
melted_correlation_matrix$Var2 <- factor(melted_correlation_matrix$Var2, levels(melted_correlation_matrix$Var2)[seq(length(levels(melted_correlation_matrix$Var2)), 1, by = -1)], ordered = TRUE)

labels_plot <- sapply(levels(melted_correlation_matrix[,1]), function(x) gsub("_", "", x))

ggplot(data = melted_correlation_matrix, aes(x = Var1, y = Var2, fill = value)) + geom_tile(color = "white") + xlab("") + ylab("") + scale_fill_gradient2(low = "darkorchid4", high = "green3", mid = "white", midpoint = 0, na.value = "white", limit = c(-1, 1), name = "Correlation") + scale_x_discrete(labels = labels_plot) + scale_y_discrete(labels = labels_plot[length(labels_plot):1]) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),                                     
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_rect(fill = "white"),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.7, 0.7),
  legend.direction = "horizontal") + guides(fill = guide_colorbar(barwidth = 7, barheight = 1, title.position = "top", title.hjust = 0.5))
```

```{r, eval = FALSE}
# quickpred: quick selection procedure of predictors
# select predictors according to data relations with a minimum correlation of ρ = 0.25
mice_in2 <- mice::mice(indication_for_mice, pred = mice::quickpred(indication_for_mice, mincor = 0.25), print = FALSE)
mice_in2$pred
```

Modify the predictor matrix such that only sponsor type is imputed, using all variables.

```{r}
predictor_matrix[,"covid"] <- 1 # no need to set element in row 'covid' to 0 because the entire row will be set to 0 below
predictor_matrix[which(!(row.names(predictor_matrix) %in% c("sponsor_type"))),] <- 0
```

Generate 10 imputed datasets using chained equations (using package `mice`).

```{r}
indication_mice <- mice::mice(indication_for_mice, m = 10, pred = predictor_matrix, print = FALSE)

attributes(indication_mice)
```

Original data:

```{r}
indication_mice$data %>% head
```

Imputed datasets:

```{r}
indication_mice$imp %>% map(head)

# In order to get the third imputed data set, use the complete() function
```

Only impute sponsor type.

```{r}
method_vector <- indication_mice$method
method_vector[-15] <- ""

# methods(mice)
```

Generate 10 imputed datasets using the updated `method` vector.

```{r}
indication_mice <- mice::mice(indication_for_mice, method = method_vector, m = 10, pred = predictor_matrix, print = FALSE)
```

```{r}
plot(indication_mice)
```

Check that there is no trend with further iterations and that the lines mix.

```{r}
indication_mice_40 <- mice::mice.mids(indication_mice, maxit = 40, print = FALSE)
plot(indication_mice_40)
```

Plot of observed (blue) and imputed (red) phase:

```{r}
mice::stripplot(indication_mice, phase_clean ~ .imp, pch = 20, cex = 2)

# Under MCAR, univariate distributions of the observed and imputed data are expected to be identical. Under MAR, they can be different, both in location and spread, but their multivariate distribution is assumed to be identical.
```

```{r}
mice::stripplot(indication_mice)
```

##### Analysis

Logistic regression analysis on the multiply imputed data.

```{r total models indication mice}
indication_total_models_mice <- lapply(myvars, function (x){
  fit <- with(indication_mice, glm(as.formula(paste(x, "~", paste(indication_total_adjustment, collapse = "+"))),
                             family = binomial(link = "logit")))
  pooled_fit <- mice::pool(fit)
  return(list("fit" = fit, "pooled_fit" = pooled_fit))
                            })

names(indication_total_models_mice) <- myvars
```

```{r total models indication results mice, fig.height = forestplot_height}
lapply(indication_total_models_mice, function(x) summary(x$pooled_fit))

sum_indication_total_mice <- lapply(indication_total_models_mice, function(x) summary(x$pooled_fit))

# OR and 95% CI (Bonferroni corrected)
pool_OR_indication_total_mice <- lapply(sum_indication_total_mice, function(x) {
  cbind(exp(cbind(x[2,2], (x[2,2]-z*(x[2,3])), 
           (x[2,2]+z*(x[2,3])))), x[2,6])
})

pool_OR_indication_total_mice <- do.call(rbind.data.frame, pool_OR_indication_total_mice)
pool_OR_indication_total_mice$Analysis <- "IM total (7)"

```

`fmi`: fraction of information about the coefficients missing due to nonresponse  
`lambda`: proportion of the variation attributable to the missing data  

```{r}
mice::densityplot(indication_mice, ~ sponsor_type)
```

##### Compare complete case analysis with MICE analysis for the each outcome

###### Control arm

```{r}
summary(glm(as.formula(paste("control_arm", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("control_arm", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Randomisation

```{r}
summary(glm(as.formula(paste("randomisation", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("randomisation", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Blinding

```{r}
summary(glm(as.formula(paste("blinding", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("blinding", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

###### Prospective registration

```{r}
summary(glm(as.formula(paste("prospective", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit"), data = indication_dataset))

fit <- with(indication_mice, glm(as.formula(paste("prospective", "~", paste(indication_total_adjustment, collapse = "+"))), family = binomial(link = "logit")))
pooled_fit <- mice::pool(fit)
pooled_fit$pooled
summary(pooled_fit)
```

## E-value (analysis 8)

E-values are calculated below.

```{r evalues}
#control arm main direct
control_direct_e <- EValue::evalues.OR(est = 2.18,
                                       lo = 1.48,
                                       hi = 3.21,
                                       rare = 0, 
          # 1 if the outcome <15% at end of follow up
                                       true = 1) 
        # odds ratio for which we want to calculate e-value (i.e. H0)

# randomisation main direct
randomisation_direct_e <- EValue::evalues.OR(est = 1.9,
                                             lo = 1.34,
                                             hi = 2.69,
                                             rare = 0, 
                                             true = 1) 

# control main total
control_total_e <- EValue::evalues.OR(est = 2.2,
                                      lo = 1.57,
                                      hi = 3.08,
                                      rare = 0, 
                                      true = 1) 

# randomisation main total
randomisation_total_e <- EValue::evalues.OR(est = 1.93,
                                            lo = 1.42,
                                            hi = 2.6,
                                            rare = 0, 
                                            true = 1) 
bind_rows(control_direct_e[2,],
          randomisation_direct_e[2,],
          control_total_e[2,],
          randomisation_total_e[2,]) %>% 
  rename(Point = point, 
         Lower = lower) %>% 
  mutate(Analysis = c("Control arm direct effect",
                      "Randomisation direct effect",
                      "Control arm total effect",
                      "Randomisation total effect")) %>% 
  select(Analysis, everything(), -upper)



```

## Geographic regions as confounders (analysis 9)

Analyses 6 and 7 are repeated with geographical regions included as coviariates.

```{r total models main sens mice}
#  analysis 6 repeated
locations <- main_dataset %>%
  select(region_Africa:region_Oceania) %>%
  names()
region_sens_adjustment <- c(main_total_adjustment, locations)

main_sens_models_mice <- lapply(myvars, function (x){
  fit <- with(main_mice, glm(as.formula(paste(x, "~", paste(region_sens_adjustment, collapse = "+"))),
                             family = binomial(link = "logit")))
  pooled_fit <- mice::pool(fit)
  return(list("fit" = fit, "pooled_fit" = pooled_fit))
                            })

names(main_sens_models_mice) <- myvars

lapply(main_sens_models_mice, function(x) summary(x$pooled_fit))

sum_main_sens_mice <- lapply(main_sens_models_mice, function(x) summary(x$pooled_fit))

# OR and 95% CI (Bonferroni corrected)
pool_OR_main_sens_mice <- lapply(sum_main_sens_mice, function(x) {
  cbind(exp(cbind(x[2,2], (x[2,2]-z*(x[2,3])), 
           (x[2,2]+z*(x[2,3])))), x[2,6])
})
do.call(rbind.data.frame, pool_OR_main_sens_mice) 

pool_OR_main_sens_mice <- do.call(rbind.data.frame, pool_OR_main_sens_mice)
pool_OR_main_sens_mice$Analysis <- "Main total sensitivity (9)"

```

```{r total models indication sens mice}
# analysis 7 repeated 
indication_sens_models_mice <- lapply(myvars, function (x){
  fit <- with(indication_mice, glm(as.formula(paste(x, "~", paste(region_sens_adjustment, collapse = "+"))),
                             family = binomial(link = "logit")))
  pooled_fit <- mice::pool(fit)
  return(list("fit" = fit, "pooled_fit" = pooled_fit))
                            })

names(indication_sens_models_mice) <- myvars

lapply(indication_sens_models_mice, function(x) summary(x$pooled_fit))

sum_indication_sens_mice <- lapply(indication_sens_models_mice, function(x) summary(x$pooled_fit))

# OR and 95% CI (Bonferroni corrected)
pool_OR_indication_sens_mice <- lapply(sum_indication_sens_mice, function(x) {
  cbind(exp(cbind(x[2,2], (x[2,2]-z*(x[2,3])), 
           (x[2,2]+z*(x[2,3])))), x[2,6])
})

pool_OR_indication_sens_mice <- do.call(rbind.data.frame, pool_OR_indication_sens_mice)
pool_OR_indication_sens_mice$Analysis <- "IM total sensitivity (9)"

```

## Analysis 10

Analysis without inferring outcomes. 

Create datasets.

```{r datasets}
  
main_dataset_2_control <- main_dataset_2[!is.na(main_dataset_2$control_arm), ]
main_dataset_2_randomisation <- main_dataset_2[
  !is.na(main_dataset_2$randomisation) & 
    main_dataset_2$randomisation != "Not applicable", 
  ]
main_dataset_2_blinding <- main_dataset_2[!is.na(main_dataset_2$blinding), ]


indication_dataset_2_control <- indication_dataset_2[!is.na(indication_dataset_2$control_arm), ]
indication_dataset_2_randomisation <- indication_dataset_2[
  !is.na(indication_dataset_2$randomisation) & 
    indication_dataset_2$randomisation != "Not applicable", 
  ]
indication_dataset_2_blinding <- indication_dataset_2[!is.na(indication_dataset_2$blinding), ]

table(indication_dataset_2$control_arm, useNA = "a")
table(indication_dataset_2$randomisation, useNA = "a")
table(indication_dataset_2$blinding, useNA = "a")

table(indication_dataset_2_control$control_arm, useNA = "a")
table(indication_dataset_2_randomisation$randomisation, useNA = "a")
table(indication_dataset_2_blinding$blinding, useNA = "a")

# nothing to do for prospective

```

Main direct adjustment with only non-inferred outcomes.

```{r analysis ten part 4}

main_direct_models_10 <- list()

main_direct_models_10[[1]] <- glm(
  as.formula(paste("control_arm", "~", paste(main_direct_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = main_dataset_2_control)

# source registry needs to be grouped further because it created convergence
# issues
main_dataset_2_randomisation <- main_dataset_2_randomisation %>% 
  mutate(source_registry = fct_lump_n(
    main_dataset_2_randomisation$source_registry, n = 5))

main_direct_models_10[[2]]<- glm(
  as.formula(paste("randomisation", "~", paste(main_direct_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = main_dataset_2_randomisation)

main_direct_models_10[[3]]<- glm(
  as.formula(paste("blinding", "~", paste(main_direct_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = main_dataset_2_blinding)

sjPlot::plot_models(main_direct_models_10, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1)

coef_names <- names(coef(main_direct_models_10[[1]]))

sjPlot::plot_models(main_direct_models_10, 
                    prefix.labels = "varname",
                    rm.terms = coef_names[3:length(coef_names)])+
  theme_bw() + geom_hline(yintercept = 1)

```

Indication matched direct adjustment with only non-inferred outcomes.

```{r analysis ten part 5}

indication_direct_models_10 <- list()

indication_direct_models_10[[1]] <- glm(
  as.formula(paste("control_arm", "~", paste(indication_direct_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = indication_dataset_2_control)

indication_direct_models_10[[2]]<- glm(
  as.formula(paste("randomisation", "~", paste(indication_direct_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = indication_dataset_2_randomisation)

indication_direct_models_10[[3]]<- glm(
  as.formula(paste("blinding", "~", paste(indication_direct_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = indication_dataset_2_blinding)

sjPlot::plot_models(indication_direct_models_10, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1)

coef_names <- names(coef(indication_direct_models_10[[1]]))

sjPlot::plot_models(indication_direct_models_10, 
                    prefix.labels = "varname",
                    rm.terms = coef_names[3:length(coef_names)])+
  theme_bw() + geom_hline(yintercept = 1)

```

Main total adjustment with only non-inferred outcomes.

```{r analysis ten part 6}
main_total_models_10 <- list()

main_total_models_10[[1]] <- glm(
  as.formula(paste("control_arm", "~", paste(main_total_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = main_dataset_2_control)

main_total_models_10[[2]]<- glm(
  as.formula(paste("randomisation", "~", paste(main_total_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = main_dataset_2_randomisation)

main_total_models_10[[3]]<- glm(
  as.formula(paste("blinding", "~", paste(main_total_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = main_dataset_2_blinding)

sjPlot::plot_models(main_total_models_10, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1)

```

Indication matched total adjustment with only non-inferred outcomes.

```{r analysis ten part 7}
indication_total_models_10 <- list()

indication_total_models_10[[1]] <- glm(
  as.formula(paste("control_arm", "~", paste(indication_total_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = indication_dataset_2_control)

indication_total_models_10[[2]]<- glm(
  as.formula(paste("randomisation", "~", paste(indication_total_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = indication_dataset_2_randomisation)

indication_total_models_10[[3]]<- glm(
  as.formula(paste("blinding", "~", paste(indication_total_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = indication_dataset_2_blinding)

sjPlot::plot_models(indication_total_models_10, prefix.labels = "varname") + theme_bw() + geom_hline(yintercept = 1)


```


## Overall results
```{r}

colnames(pool_OR_main_direct_mice) <- colnames(pool_OR_indication_direct_mice)

result <- bind_rows(pool_OR_main_direct_mice,
                    pool_OR_indication_direct_mice,
                    pool_OR_main_total_mice,
                    pool_OR_indication_total_mice,
                    pool_OR_main_sens_mice,
                    pool_OR_indication_sens_mice)

colnames(result) <- c("Estimate", "Lower.CI", "Upper.CI", "P-Value", "Analysis")
result$Outcome <- rep(c("Control arm", "Randomisation", "Blinding" , "Prospective"), 6)

result <- result %>% 
  select(Analysis, Outcome, everything())

rownames(result) <- NULL
result_t <- result
result_t[3:6] <-lapply(result[3:6], signif, digits=3)

result_t$x <- paste0(result_t$Estimate, " [", 
       result_t$Lower.CI, "-", result_t$Upper.CI, "]")

result_t

x <- result %>% 
  transform(
    Analysis = factor(
      Analysis, levels = c("Main direct (4)", 
                           "IM direct (5)",
                           "Main total (6)",
                           "IM total (7)",
                           "Main total sensitivity (9)",
                           "IM total sensitivity (9)")),
    Outcome = factor(
      Outcome, levels = c("Prospective",
                          "Blinding",
                          "Randomisation",
                          "Control arm")
    ))
  
p <- ggplot(x, aes(Outcome, Estimate)) + 
  geom_point() +
  geom_errorbar(aes(ymin = Lower.CI, ymax = Upper.CI)) +
  geom_hline(yintercept=1, linetype="dashed", color = "red") +
  labs(y = "Odds ratio")

p <- p + coord_flip()
p + facet_wrap(~Analysis, ncol = 1) +
  theme_light()

```

### Analysis 10 summary results

```{r}
all_models_10 <- c(main_direct_models_10, indication_direct_models_10,
                   main_total_models_10, indication_total_models_10)

names(all_models_10) <- rep(c("control_arm", "randomisation", "blinding"), 4)

sum_10 <- lapply(all_models_10, summary)
sum_10 <- lapply(sum_10, function (x) x[["coefficients"]])

pool_OR_all_10 <- lapply(sum_10, function(x) {
  cbind(exp(cbind(x[2,1], (x[2,1]-z*(x[2,2])), 
           (x[2,1]+z*(x[2,2])))), x[2,4])
})

result_10 <- do.call(rbind.data.frame, pool_OR_all_10)

colnames(result_10) <- c("Estimate", "Lower.CI", "Upper.CI", "P-Value")
result_10$Outcome <- rep(c("Control arm", "Randomisation", "Blinding"), 4)
result_10$Analysis <- c(rep("Main direct (4)", 3),
                      rep("IM direct (5)", 3),
                      rep("Main total (6)", 3),
                      rep("IM total (7)", 3))

result_10 <- result_10 %>% 
  select(Analysis, Outcome, everything())

rownames(result_10) <- NULL
result_10_t <- result_10
result_10_t[3:6] <-lapply(result_10[3:6], signif, digits=3)

result_10_t$x <- paste0(result_10_t$Estimate, " [", 
       result_10_t$Lower.CI, "-", result_10_t$Upper.CI, "]")

result_10_t

```

```{r}
x <- result_10 %>% 
  transform(
    Analysis = factor(
      Analysis, levels = c("Main direct (4)", 
                           "IM direct (5)",
                           "Main total (6)",
                           "IM total (7)")),
    Outcome = factor(
      Outcome, levels = c("Blinding",
                          "Randomisation",
                          "Control arm")
    ))
  
p <- ggplot(x, aes(Outcome, Estimate)) + 
  geom_point() +
  geom_errorbar(aes(ymin = Lower.CI, ymax = Upper.CI)) +
  geom_hline(yintercept=1, linetype="dashed", color = "red") +
  labs(y = "Odds ratio")

p <- p + coord_flip()
p + facet_wrap(~Analysis, ncol = 1) +
  theme_light()

```


# Exploratory analysis
The code used to define the adjustment sets is given in a separate script.

•	Control arm: sample size, sponsor type, regions, phase, intervention type, and primary purpose. 
•	Randomisation: sample size, sponsor type, region, control arm, multicentre, vaccine (i.e. a particular intervention type) and primary purpose 
•	Blinding: sample size, sponsor type, randomisation, region, control arm, phase, intervention type, primary purpose 
•	Prospective registration: sample size, sponsor type, region, phase, conventional (i.e. a particular intervention type)

```{r}
control_adjustment <- c("covid",
                        "sample_size", "sponsor_type", 
                        "region_Africa", "region_N_America",
                        "region_L_America", "region_N_America",
                        "region_Oceania",
                        "phase_clean", 
                        "vaccine", "conventional", "traditional",
                        "primary_purpose")

randomisation_adjustment <- c("covid",
                              "sample_size", "sponsor_type", 
                        "region_Africa", "region_N_America",
                        "region_L_America", "region_N_America",
                        "region_Oceania",
                        #"control_arm", leads to issues with convergence
                        "multicentre", 
                        "vaccine", "primary_purpose")

blinding_adjustment <- c("covid",
                         "sample_size", "sponsor_type",
                         "randomisation",
                         "region_Africa", "region_N_America",
                        "region_L_America", "region_N_America",
                        "region_Oceania", 
                       # "control_arm", leads to issues with convergence
                        "phase_clean",
                        "vaccine", "conventional", "traditional",
                        "primary_purpose")

prospective_adjustment <- c("covid",
                            "sample_size", "sponsor_type", 
                            "region_Africa", "region_N_America",
                            "region_L_America", "region_N_America",
                            "region_Oceania",
                            "phase_clean", 
                            "conventional")
```

Complete cases are used for the exploratory analysis.
```{r}
d1 <- d %>% 
  select(study_arm:traditional) %>% 
  filter(study_arm == "covid" |
           study_arm == "main")
d1 <- d1[complete.cases(d1),]

d1$covid <- ifelse(d1$study_arm == "covid", "Yes", "No")

```

```{r}
control_exp <- glm(as.formula(
  paste0("control_arm", "~",
         paste(control_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = d1)

sjPlot::plot_model(control_exp, ci.lvl = 1-0.0125)
sjPlot::tab_model(control_exp)

randomisation_exp <- glm(as.formula(
  paste0("randomisation", "~",paste(randomisation_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = d1)

sjPlot::plot_model(randomisation_exp, ci.lvl = 1-0.0125)
sjPlot::tab_model(randomisation_exp)

blinding_exp <- glm(as.formula(
  paste0("blinding", "~",paste(blinding_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = d1)

sjPlot::plot_model(blinding_exp, ci.lvl = 1-0.0125)
sjPlot::tab_model(blinding_exp)

prospective_exp <- glm(as.formula(
  paste0("prospective", "~",paste(prospective_adjustment, collapse = "+"))),
  family = binomial(link = "logit"),
  data = d1)

sjPlot::plot_model(prospective_exp, ci.lvl = 1-0.0125)
sjPlot::tab_model(prospective_exp)

```



```{r, echo = FALSE, cache = FALSE}
knitr::knit_exit()
```

# END
